---
title: "Cholera outbreak report"
author: "Cox's Bazar MSF-OCA Epidemiology Team"
output:
  word_document:
    reference_docx: template_episitrep.docx
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---


<!-- ## Installing and loading required packages  -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// setup \\\
--------------------------------------------------------------------------------

Several packages are required for different aspects of  analysis with *R*. 
You will need to install these before starting. 

These packages can be quite large and may take a while to download in the
field. If you have access to a USB key with these packages, it makes sense to
copy and paste the packages into your computer's R package library 
(run the command .libPaths() to see the folder path). 

For help installing packages, please visit https://r4epis.netlify.com/welcome
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


```{r setup, include=FALSE, results='hide', message=FALSE, warning=FALSE}
## hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = FALSE,       # hide all code chunks in output
                      error = TRUE,       # show errors if they appear, but don't stop
                      fig.width = 6*1.25, # Figure width
                      fig.height = 6      # Figure height
                     )



## set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")



## Installing required packages for this template
required_packages <- c("knitr",       # create output docs
                       "here",        # find your files
                       "dplyr",       # clean/shape data
                       "forcats",     # clean/shape data
                       "stringr",     # clean text
                       "rio",         # read in data
                       "ggplot2",     # create plots and charts
                       "patchwork",   # combine plots in one
                       "sitrep",      # MSF field epi functions
                       "linelist",    # Functions for cleaning/standardising data/dates
                       "matchmaker",  # dictionary-based standardization of variables
                       "incidence",   # create epicurves
                       "aweek",       # define epi weeks
                       "epitrix",     # epi helpers and tricks
                       "raster",      # for mapping
                       "sf",          # encode spatial vector data
                       "ggspatial",   # plot maps
                       "gtsummary",   # make beautiful tables
                       "tsibble")     # make epiweeks

for (pkg in required_packages) {
  # install packages if not already present
  if (!pkg %in% rownames(installed.packages())) {
    install.packages(pkg)
  }
  
  # load packages to this current session 
  library(pkg, character.only = TRUE)
}



## Set default options for plots and charts

## set default text size to 16 for plots
## give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 12))

## sets the theme in ggplot for epicurves
epicurve_theme <- theme(
  text=element_text(size=10), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
  legend.title = element_blank(),
  panel.grid.major.x = element_line(color = "grey60", linetype = 3),
  panel.grid.major.y = element_line(color = "grey60", linetype = 3))
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// define_current_week \\\
--------------------------------------------------------------------------------

You need to set the week you want to report on. Generally, this is the previous
week. Put it below.

aweek::set_week_start will define the beginning of the week. The standard is
Monday.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r define_current_week}
## set current week 
reporting_week <- yearweek("2021 W05", week_start = 7)

## sets the labels in ggplot for the epicurves
# epicurve_labels <- labs(x = "Calendar week", 
#                         y = "Cases (n)", 
#                         title = "Cases by week of onset",
#                         subtitle = str_glue("Source: MSF data from {reporting_week}")
#                        ) 
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// read_nonDHIS_data \\\
--------------------------------------------------------------------------------

This section is for data not from DHIS2.
If you have already loaded data from DHIS2, go to read_population_data.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r read_nonDHIS_data, warning = FALSE, message = FALSE}

## Excel file ------------------------------------------------------------------
## to read in a specific sheet use "which"
linelist_raw <- rio::import(here::here("4_data", 
                                       "AWD_R Analysis_Linelist_2020.xlsx"),
                            which = "AWD Linelist")
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// prep_nonDHIS_data \\\
--------------------------------------------------------------------------------

This section is for data not from DHIS2. 
If you have already loaded data from DHIS2, go to read_population_data.

It is more difficult to prepare the nonDHIS data. You can do it! It will just
take a little more work.

Checklist to update this script to match your data:
[ ] Comment out all lines in read_DHIS_data and prep_DHIS_data
[ ] Recode your variable names to match the dictionary
[ ] Recode variable contents to match the dictionary


This step shows you the data dictionary. The data dictionary has variable names
in the data_element_shortname column. Possible values for each variable are
specified in code and name columns. Code has the shortened value and Name has
the full-text value.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r prep_nonDHIS_data, warning = FALSE, message = FALSE}

## Clean column names ----------------------------------------------------------
## This step fixes the column names so they are easy to use in R.

## make a copy of your orginal dataset and name it linelist_cleaned
linelist_cleaned <- linelist_raw %>% 
  ## make all column names lower case
  janitor::clean_names()

## Match column names ---------------------------------------------------------
## This step helps you match your variables to the standard variables.
## This step will require some patience. Courage!

## Use the function msf_dict_rename_helper() to create a template based on the
## cholera dictionary. This will copy a rename command like the one above to your
## clipboard.

msf_dict_rename_helper("Cholera")

## Paste the result below and your column names to the matching variable.
## Be careful! You still need to be aware of what each variable means and what
## values it takes.
## If there are any variables that are in the MSF dictionary that are not in
## your data set, then you should comment them out, but be aware that some
## analyses may not run because of this. 

## Add the appropriate column names after the equals signs

linelist_cleaned <- rename(linelist_cleaned,
  # age_days                         =   , # INTEGER_POSITIVE  (REQUIRED)
  age_months                       =   age_months_0_if_more_than_1, # INTEGER_POSITIVE  (REQUIRED)
  age_years                        =   age_years_0_if_less_than_1, # INTEGER_POSITIVE  (REQUIRED)
  case_number                      =   case_id, # TEXT              (REQUIRED)
  # cholera_culture_result           =   , # TEXT              (REQUIRED)
  # cholera_pcr_result               =   , # TEXT              (REQUIRED)
  cholera_rdt_result               =   rdt_result_positive_negative_nd_not_done, # TEXT              (REQUIRED)
  cholera_treatment_facility_type  =  settlement_ktp_bkl , # TEXT              (REQUIRED)
  date_of_consultation_admission   =   date_of_visit_admission_dd_mm_yy, # DATE              (REQUIRED)
  date_of_exit                     =   date_discharge, # DATE              (REQUIRED)
  # date_of_last_vaccination         =   , # DATE              (REQUIRED)
  date_of_onset                    =  date_of_onset_of_symptoms , # DATE              (REQUIRED)
  dehydration_level_at_admission   =   dehydration_y_n, # TEXT              (REQUIRED)
  # dehydration_severity_during_stay =   , # TEXT              (REQUIRED)
  exit_status                      =  outcome_discharged_1_died_2_absconded_3_admission_4_referred_5 , # TEXT              (REQUIRED)
  fluids_treatment_plan            =   treatment_plan_on_admission_a_b_or_c, # TEXT              (REQUIRED)
  patient_origin                   =   camp, # ORGANISATION_UNIT (REQUIRED)
  # previously_vaccinated            =   , # TEXT              (REQUIRED)
  # readmission                      =   , # TEXT              (REQUIRED)
  sex                              =   sex_m_f, # TEXT              (REQUIRED)
  # time_to_death                    =   , # TEXT              (REQUIRED)
  # arrival_date_in_area_if_3m       =   , # DATE              (optional)
  # cholera_referred_from            =   , # TEXT              (optional)
  # cholera_referred_to              =   , # TEXT              (optional)
  # comments_on_lab_results          =   , # LONG_TEXT         (optional)
  date_lab_sample_taken            =   date_of_lab_specimen_taken, # DATE              (optional)
  # delivery_event                   =   , # TRUE_ONLY         (optional)
  # event_file_type                  =   , # TEXT              (optional)
  # foetus_alive_at_admission        =   , # TEXT              (optional)
  # iv_fluids_received_litres        =   , # INTEGER_POSITIVE  (optional)
  # malaria_rdt_at_admission         =   , # TEXT              (optional)
  # msf_involvement                  =   , # TEXT              (optional)
  # oedema                           =   , # BOOLEAN           (optional)
  # ors_consumed_litres              =   , # INTEGER_POSITIVE  (optional)
  patient_origin_free_text         =  block , # TEXT              (optional)
  # pregnancy_outcome_at_exit        =   , # TEXT              (optional)
  pregnant                         =   pregnant_y_n, # TEXT              (optional)
  prescribed_antibiotics           =  medications_taken_n_none_a_antibiotics_o_other , # BOOLEAN           (optional)
  # prescribed_zinc_supplement       =   , # BOOLEAN           (optional)
  previous_vaccine_doses_received  =  received_cholera_vaccine_0_1_2_doses , # TEXT              (optional)
  # residential_status_brief         =   , # TEXT              (optional)
  # treatment_facility_name          =   , # TEXT              (optional)
  # treatment_facility_site          =   , # TEXT              (optional)
  # treatment_location               =   , # ORGANISATION_UNIT (optional)
  trimester                        =   pregnant_trimester  # TEXT              (optional)
)

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// browse_data \\\
--------------------------------------------------------------------------------

You'll want to look at your data. Here are a few ways you can explore.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r browse_data, eval = FALSE}
## view the first ten rows of data
# head(linelist_cleaned, n = 10)
# 
# ## view your whole dataset interactively (in an excel style format)
# View(linelist_cleaned)
# 
# ## overview of variable types and contents
# str(linelist_cleaned)
# 
# ## get summary: 
# ## mean, median and max values of numeric variables
# ## counts for categorical variables
# ## also gives number of NAs
# summary(linelist_cleaned)
# 
# ## view unique values contained in variables 
# ## you can run this for any column -- just replace the column name
# unique(linelist_cleaned$patient_origin) 

```




<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// remove_unused_data \\\
--------------------------------------------------------------------------------

Your data might have empty rows or columns you want to remove.
You can also use this section to create temporary datasets so you can review
specific variables or rows.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r remove_unused_data}
## Drop unused rows  -----------------------------------------------------------
## This step removes blank rows that don't have both a date of admission and ID
## number.
linelist_cleaned <- linelist_cleaned %>% 
  filter(!is.na(case_number) & !is.na(date_of_consultation_admission)) 


```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This part of the script will create and clean variables in your data.

All your cleaning and variable creation should happen in these chunks.
That way, in case something goes wrong, you can push the small arrow at the top
of the chunk to re-run all the code chunks up to the current one.

The chunks are:
- standardise_dates -- will set up and clean dates.
- create_age_group  -- creates the age group variables from age
- create_vars       -- creates variables based on other variables
- factor_vars       -- helps clean factor variables
- vector_vars       -- creates groups of variables for easy use


You must adapt this section according to your data!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// standardise_dates \\\
--------------------------------------------------------------------------------

This chunk will help you set up and clean your date variables.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r standardise_dates}

## Non-DHIS2 data --------------------------------------------------------------
## Use this section if you did not have DHIS2 data. 

## use the guess_dates() function to make a first pass at date variables.
 linelist_cleaned <- linelist_cleaned %>%
   mutate_at(c("date_of_consultation_admission",
               "date_of_onset",
               "date_of_exit"), linelist::guess_dates,
           error_tolerance = 0.5)

## once you have run guess_dates(), take a look at your date variables.
## here is an example:
# table(linelist_cleaned$date_of_consultation_admission)


## Some dates will be unrealistic or wrong.
## Here is an example of how to manually fix dates. 
## Look at your data and edit as needed.
# linelist_cleaned <- mutate(linelist_cleaned,
#                            date_of_onset = case_when(
#                              date_of_onset < as.Date("2017-11-01")  ~ as.Date(NA),
#                              date_of_onset == as.Date("2081-01-01") ~ as.Date("2018-01-01"),
#                              TRUE                                   ~ date_of_onset
#                            ))
  


## Create epiweek variable -----------------------------------------------------
## This step creates an epiweek variable from the date of onset.
## You can use date_of_consultation_admission if you are missing many date_of_onset.

linelist_cleaned$epiweek <- yearweek(linelist_cleaned$date_of_onset, 
                                             week_start = 7)

```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// create_age_group \\\ 
--------------------------------------------------------------------------------

This chunk will help you set up your age group variable.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r create_age_group}

## Age group variables ----------------------------------------------------------
## This step shows you how to create categorical variables from numeric variables.
## We have some intermediate steps on the way.


## OPTIONAL: add under 2 years to the age_years variable
## data dictionary defines that under 2s dont have year filled in (but months/days instead)
linelist_cleaned <- linelist_cleaned %>% 
  mutate( age_years = case_when(
    # is.na(age_years) & is.na(age_months) ~ as.numeric(age_days / 365.25),
    is.na(age_years)                     ~ as.numeric(age_months / 12),
    TRUE                                 ~ as.numeric(age_years)
  ))



## create age group variable for under 5 years based on months
linelist_cleaned$age_group_mon <- age_categories(linelist_cleaned$age_months, 
                                                 breakers = c(0, 6, 9, 12, 24), 
                                                 ceiling = TRUE)

## create an age group variable by specifying categorical breaks
linelist_cleaned$age_group <- age_categories(linelist_cleaned$age_years, 
                                             breakers = c(0, 3, 15, 30, 45))

```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// create_vars \\\
--------------------------------------------------------------------------------

This chunk will help you construct new variables from other variables. It
includes numeric, factor, and character vectors.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r create_vars}

## Numeric variables -----------------------------------------------------------
## This step creates a variable for number of days under observation.
## You can adapt this step to create other calculated variables

## create number of days under observation
linelist_cleaned <- mutate(linelist_cleaned, 
                           obs_days = as.numeric(date_of_exit - 
                                                   date_of_consultation_admission))

## The variable DIED will be binary (TRUE/FALSE) -- if patient died or not
linelist_cleaned <- linelist_cleaned %>% 
  mutate(DIED = if_else(exit_status == 2, TRUE, FALSE))

## create a previously vaccinated variable taking the values from the number of doses variable
linelist_cleaned <- linelist_cleaned %>% 
  mutate(previously_vaccinated = if_else(previous_vaccine_doses_received >= 1, "Yes",
                                         if_else(is.na(previous_vaccine_doses_received) == TRUE, "Unknown", "No")))

## Factor (categorical) variables ----------------------------------------------

# linelist_cleaned <- linelist_cleaned %>% 
#   ## add labels to exit status
#   mutate(exit_status_cat = factor(exit_status,
#                                   levels = c("1", "2","3", "4", "5"),
#                                   labels = c("Discharged", "Died", "Absconded",
#                                              "Admission", "Referred")))
  




## Recode character variables -------------------------------------------------
## Recode values of sex variable to match the analysis
linelist_cleaned <- linelist_cleaned %>% 
  mutate(sex = if_else(sex == "F", "Female", "Male"))

## recode values of fluids_treatment_plan
linelist_cleaned <- linelist_cleaned %>% 
  mutate(fluids_treatment_plan = if_else(fluids_treatment_plan == "A", "Treatment plan A",
                                         if_else(fluids_treatment_plan == "B", 
                                                 "Treatment plan B", "Treatment plan C")))



## Create a site_name variable to match with the shapefile coding
linelist_cleaned <- linelist_cleaned %>% 
  ## create site name which Camp before the camp number
  mutate(site_name  = paste0("Camp ",patient_origin)) %>% 
  ## replace lower case e to upper case
  mutate(site_name = str_replace(site_name, "e", "E")) %>% 
  ## replace lower case w to upper case
  mutate(site_name = str_replace(site_name, "w", "W"))

## sometimes, coding is inconsistent across variables -- for example, "Yes" / "No"
## may be coded as Y, y, yes, 1 / N, n, no, 0. You can change them all at once!
## Create a list of the variables you want to change, and run the following.
## You may need to edit this code if options are different in your data.

## create list of variables (modify according to your data needs)
# change_yn <- c("readmission", "pregnant", "prescribed_zinc_supplement")

## standardize options
# linelist_cleaned <- linelist_cleaned %>%  
#      mutate_at(vars(change_yn), forcats::fct_recode,   
#      Yes = "y",  
#      Yes = "Y",  
#      Yes = "yes",  
#      Yes = "1",   
#      No  = "n",  
#      No  = "N",  
#      No  = "no",  
#      No  = "0",  
#    )     



## Create a variable based on rules from other simple character variables
## If you have access to lab results, you can create a case definition variable 
## the tilda (~) is used to assign the new values (Conf, prob, susp, unknown)
## starting from the specific to the general
## TRUE assigns all remaining rows 
## You MUST modify this section to match your case definition. The below
## uses positive PCR or culture result for Confirmed and positive RDT for
## Probable.
# 
# linelist_cleaned <- linelist_cleaned %>%
#   mutate(case_def = case_when(
#     is.na(cholera_pcr_result) &
#       is.na(cholera_culture_result) &
#       is.na(cholera_rdt_result)                    ~ NA_character_,
#     str_detect(cholera_pcr_result, "Positive")     ~ "Confirmed",  
#     str_detect(cholera_culture_result, "Positive") ~ "Confirmed",
#     str_detect(cholera_rdt_result, "Positive")     ~ "Probable",
#     TRUE                                           ~ "Suspected"
#   ))



## Fix logically inconsistent variables
## example: if no vaccine given previously or if unsure, data of last vax
## should be NA
# 
# linelist_cleaned <- linelist_cleaned %>%
#   mutate(date_of_last_vaccination = ifelse(
#     previously_vaccinated != "Yes", 
#     (date_of_last_vaccination), as.Date(NA)
#   ))
```
  


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// factor_vars \\\
--------------------------------------------------------------------------------

This chunk will help you clean factor variables.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r factor_vars}

## Force missing values to NA
## important for sex to generate age pyramids
linelist_cleaned$sex <- fct_recode(linelist_cleaned$sex, 
                                   NULL = "Unknown/unspecified")


## Change the order of levels in a single categorical variable 
## This orders the levels -- since in all figures / tables, 0-4 should come
## before 4-24, etc
# linelist_cleaned <- linelist_cleaned %>% 
#   mutate(time_to_death = factor(time_to_death, 
#                                 levels = c("0-4 hours", 
#                                            ">4-24 hours", 
#                                            ">24-48 hours", 
#                                            ">48 hours")))



## Change the order of levels of multiple categorical variables at the same time
# linelist_cleaned <- linelist_cleaned %>%
#   mutate_at(vars(
#            # Looks for variables beginning with "dehydration"
#             starts_with("dehydration")),          
#             fct_relevel,
#             # Sets order of levels
#             "Severe", "Some", "None", "Unknown")
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// vector_vars \\\
--------------------------------------------------------------------------------

This chunk creates groups of variables that you might want to use together. That
way, if you want to run the same function over these variables, you can run it
all at once. For example, you may want to look at frequency of all symptoms at
the same time.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r vector_vars}
# create a grouping of all lab tests 
LABS <- c("cholera_culture_result", 
          "cholera_pcr_result", 
          "cholera_rdt_result")
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// report_setup \\\
--------------------------------------------------------------------------------

This chunk removes cases after your reporting week and defines the start and end
of the reporting period.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r report_setup}
# return the last day of the reporting week
# obs_end   <- week2date(str_glue("{reporting_week}-7"))
# 
# # filter out cases after end of reporting week
# linelist_cleaned <- linelist_cleaned %>% 
#   filter(date_of_consultation_admission <= obs_end)
# 
# # define the first week of outbreak (date of first case)
first_week <- min(linelist_cleaned$epiweek, na.rm = TRUE)


## Create a version of the linelist that only includes data up until the reporting week
linelist_cleaned_current <- linelist_cleaned %>% 
  ## filter to only include data up until the reporting week
  filter(epiweek <= reporting_week)




```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// save_cleaned_data \\\
--------------------------------------------------------------------------------

You can save your cleaned dataset as an Excel. 
This automatically names your file "linelist_cleaned_DATE", where DATE is the
current date.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r save_cleaned_data}
rio::export(linelist_cleaned, 
            here::here("4_data","clean",
                       str_glue("linelist_cleaned_{Sys.Date()}.xlsx")))
```


# Summary
This AWD SitRep covers the period from `r first_week` to `r reporting_week`. 

## Demographics of cases since the start of the outbreak
From the start of the outbreak up until `r reporting_week` there were a total of `r nrow(linelist_cleaned_current)` cases, of which `r nrow(filter(linelist_cleaned, epiweek == reporting_week))` were identified in `r reporting_week`. There were `r fmt_count(linelist_cleaned_current, sex == "Female")` females and `r fmt_count(linelist_cleaned_current, sex == "Male")` males. The most affected age group was `r tab_linelist(linelist_cleaned_current, age_group) %>% slice(which.max(n)) %>% pull(value)` years.  There have been a total of `r fmt_count(linelist_cleaned_current, exit_status == "Died")` deaths and `r fmt_count(linelist_cleaned_current, exit_status == "Admission")` admissions and `r fmt_count(linelist_cleaned_current, cholera_rdt_result == "+")` Cholera RDT positive cases. The most affected camp was `r tab_linelist(linelist_cleaned_current, patient_origin) %>% slice(which.max(n)) %>% pull(value)`.


## Clinical characteristics of cases since the start of the outbreak
There have been a total of `r fmt_count(linelist_cleaned_current, dehydration_level_at_admission == "Y")` patients dehydrated at admission. From the start of the outbreak, `r fmt_count(linelist_cleaned_current, fluids_treatment_plan == "Treatment plan A")` patients recevied treatment plan A, `r fmt_count(linelist_cleaned_current, fluids_treatment_plan == "Treatment plan B")` received treatment plan B, and `r fmt_count(linelist_cleaned_current, fluids_treatment_plan == "Treatment plan C")` received treatment plan C.



## Characteristics of cases in `r reporting_week`
In `r reporting_week`, there were `r nrow(linelist_cleaned %>% filter(epiweek == reporting_week))` cases with the most affected age group being `r tab_linelist(filter(linelist_cleaned,epiweek == reporting_week), age_group) %>% slice(which.max(n)) %>% pull(value)` years and most affected camp being `r tab_linelist(filter(linelist_cleaned,epiweek == reporting_week), patient_origin) %>% slice(which.max(n)) %>% pull(value)`. There were `r fmt_count(filter(linelist_cleaned,epiweek == reporting_week), exit_status == "Died")` deaths and `r fmt_count(filter(linelist_cleaned, epiweek == reporting_week), exit_status == "Admission")` admissions and  `r fmt_count(filter(linelist_cleaned, epiweek == reporting_week), cholera_rdt_result == "+")` Cholera RDT positive cases.


## Recommendations



<!-- Cases by age group and definition  -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_by_age_group_and_def \\\
--------------------------------------------------------------------------------

This chunk will create a table of cases by age group and case definition.
You can only use this chunk if you have lab results and have defined a case
definition variable.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r describe_by_age_group_and_def}

# tab_linelist(linelist_cleaned, 
#              # rows as age groups, with case_def as strata (columns)
#              age_group, strata = case_def, 
#              # we want row totals and column totals
#              col_total = TRUE, row_total = TRUE) %>%
#   # removes the column called variable (which just says "age_group" in this case)
#   select(-variable) %>%
#   # renames the column called value to Age group
#   rename("Age group" = value) %>%
#   # there are several columns called "proportion" - renames them to %
#   rename_redundant("%" = proportion) %>%
#   # any time there is a column that says n, we replace that with "cases (n)"
#   augment_redundant(" cases (n)" = " n$") %>%
#   # makes the table easy to read with only 2 decimal places
#   kable(digits = 1)
```



<!-- There were `r fmt_count(linelist_cleaned, is.na(sex)| sex == "Unknown/unspecified")` cases missing information on sex and `r fmt_count(linelist_cleaned, is.na(age_group))` missing age group. -->


<!-- Cases by age group and sex -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_by_age_group_and_sex \\\
--------------------------------------------------------------------------------

This chunk will create a table of cases by age group and sex.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r describe_by_age_group_and_sex, message = FALSE}

# linelist_cleaned %>% 
#   select(age_group, sex) %>% 
#   tbl_summary(missing = "always")

```

### Age-sex pyramid

<!-- Age pyramid -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// age_pyramid \\\
--------------------------------------------------------------------------------

This chunk creates an age/sex pyramid of your cases.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r age_pyramid, warning=FALSE, fig.height= 5, fig.width= 7}
 plot_age_pyramid(linelist_cleaned_current,
                  age_group = "age_group", 
                  split_by = "sex",
                  na.rm = TRUE) + 
  labs(y = "Cases (n)", x = "Age group") + # change axis  labels
  theme(legend.position = "bottom",     # move legend to bottom
        legend.title = element_blank(), # remove title
        text = element_text(size = 10)  # change text size
       )
```




<!-- From the start of the outbreak, `r fmt_count(linelist_cleaned, fluids_treatment_plan == "Treatment plan A")` patients recevied treatment plan -->
<!-- A, `r fmt_count(linelist_cleaned, fluids_treatment_plan == "Treatment plan B")` -->
<!-- received treatment plan B, and `r fmt_count(linelist_cleaned, fluids_treatment_plan == "Treatment plan C")` received treatment plan C. -->



<!-- Cases by treatment plan and case definition -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_by_treatment_plan_case_def \\\
--------------------------------------------------------------------------------

This chunk creates a table of fluids treatment plan by case definition.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r describe_by_treatment_plan_case_def}
# tab_linelist(linelist_cleaned, 
#              fluids_treatment_plan, strata = case_def,
#              col_total = TRUE, row_total = TRUE) %>% 
#   select(-variable) %>%
#   rename("Fluid treatment plan" = value) %>%
#   rename_redundant("%" = proportion) %>%
#   augment_redundant(" cases (n)" = " n$") %>%
#   kable(digits = 1)
```


<!-- The median number of days admitted was `r median(linelist_cleaned$obs_days, na.rm = T)`,  -->
<!-- with a range between `r min(linelist_cleaned$obs_days, na.rm = T)` and `r max(linelist_cleaned$obs_days, na.rm = T)` days.  -->
 



<!-- Cases by dehydration severity at admission -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_by_illness_severity_admission \\\
--------------------------------------------------------------------------------

This chunk creates a table describing the dehydration level at admission.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r describe_by_illness_severity_admission, message = FALSE}
# linelist_cleaned %>% 
#   select(dehydration_level_at_admission) %>% 
#   tbl_summary()
#           
```

<!-- Cases by lab results -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_by_labs \\\
--------------------------------------------------------------------------------


This chunk gives the counts and proportions for all of the variables in LABS.
If you do not have lab results, comment out this chunk.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r describe_by_labs}

# tab_linelist(linelist_cleaned, LABS, 
#              transpose = "variable", col_total = TRUE) %>%
#   # rename accordingly
#   rename("Results" = value) %>%
#   rename_redundant("%" = proportion, 
#                    "Culture (n)" = "_culture_", 
#                    "PCR (n)" = "_pcr_", 
#                    "RDT (n)" = "_rdt") %>%
#   kable(digits = 1)

```



<!-- Cases by vaccination status -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_by_vaccination_status \\\
--------------------------------------------------------------------------------

This chunk creates a table of the vaccination status of your cases.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r describe_by_vaccination_status}
# tab_linelist(linelist_cleaned, 
#             previously_vaccinated, 
#             col_total = TRUE) %>% 
#   select(-variable) %>%
#   rename("Vaccination status" = value, 
#          "Cases (n)" = n, 
#          "%" = proportion) %>% 
#   kable(digits = 1)
```


<!-- #### Case fatality ratio  -->

<!-- The case fatality ratio among inpatients with known outcomes is below. -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// overall_cfr \\\
--------------------------------------------------------------------------------

This chunk gives the case fatality ratio among inpatients with outcomes.
If you have no deaths reported, the table will not be useful.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r overall_cfr, warning = FALSE, message = FALSE}
# use arguments from above to produce overal CFR
# linelist_cleaned %>% 
#   # filter(patient_facility_type == "Inpatient") %>%
#   case_fatality_rate_df(deaths = DIED, mergeCI = TRUE) %>%
#   rename("Deaths" = deaths,
#          "Cases" = population,
#          "CFR (%)" = cfr,
#          "95%CI" = ci) %>%
#   kable(digits = 1)

```


<!-- The case fatality ratio by sex among inpatients with known outcomes is below.  -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// cfr_by_sex \\\
--------------------------------------------------------------------------------

This chunk gives the case fatality ratio among inpatients with outcomes, divided
by sex. If you have no deaths reported, the table will not be useful.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r cfr_by_sex, warning = FALSE, message = FALSE}
# linelist_cleaned %>%
#   filter(patient_facility_type == "Inpatient") %>%
#   mutate(sex = forcats::fct_explicit_na(sex, "-")) %>%
#   case_fatality_rate_df(deaths = DIED, group = sex, mergeCI = TRUE, add_total = TRUE) %>%
#   rename("Sex" = sex, 
#          "Deaths" = deaths, 
#          "Cases" = population, 
#          "CFR (%)" = cfr, 
#          "95%CI" = ci) %>% 
#   knitr::kable(digits = 1)
```



<!-- CFR by age group among inpatients with known outcomes -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// cfr_by_age_group \\\
--------------------------------------------------------------------------------

This chunk gives the case fatality ratio among inpatients with outcomes, divided
by age group. If you have no deaths reported, the table will not be useful.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r cfr_by_age_group, warning = FALSE, message = FALSE}

# linelist_cleaned %>%
#   filter(patient_facility_type == "Inpatient") %>%
#   case_fatality_rate_df(deaths = DIED, group = age_group, mergeCI = TRUE, add_total = TRUE) %>%
#   tidyr::complete(age_group, 
#                   fill = list(deaths = 0, 
#                               population = 0, 
#                               cfr = 0, 
#                               ci = 0)) %>% # Ensure all levels are represented
#   rename("Age group" = age_group, 
#          "Deaths" = deaths, 
#          "Cases" = population, 
#          "CFR (%)" = cfr, 
#          "95%CI" = ci) %>% 
#   knitr::kable(digits = 1)
```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// cfr_by_case_def \\\
--------------------------------------------------------------------------------

This chunk gives the case fatality ratio among inpatients with outcomes, divided
by case definition. You must have a case definition defined to use this. If you
have no deaths, the table will not be useful.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r cfr_by_case_def, warning = FALSE, message = FALSE}

# linelist_cleaned %>%
#   filter(patient_facility_type == "Inpatient") %>%
#   case_fatality_rate_df(deaths = DIED, group = case_def, 
#                         mergeCI = TRUE, add_total = TRUE) %>%
#   rename("Case definition" = case_def,
#          "Deaths" = deaths,
#          "Cases" = population,
#          "CFR (%)" = cfr,
#          "95%CI" = ci) %>%
#   knitr::kable(digits = 1)
```



<!-- #### Attack rate -->

<!-- The attack rate per 10,000 population is below (based on available population data available for the catchment area/region of interest).  -->



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// collect_variables \\\
--------------------------------------------------------------------------------

This defines your population by summing up the population by age group.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r collect_variables}
# define population 
# population <- sum(population_data_age$population)
```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
///attack_rate \\\
--------------------------------------------------------------------------------

This chunk calculates the attack rate and then shows you the confidence
intervals.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r attack_rate}
# ar <- attack_rate(nrow(linelist_cleaned), population, multiplier = 10000)
# 
# ar %>%
#   merge_ci_df(e = 3) %>% # merge the lower and upper CI into one column
#   rename("Cases (n)" = cases, 
#          "Population" = population, 
#          "AR (per 10,000)" = ar, 
#          "95%CI" = ci) %>% 
#   select(-Population) %>% # drop the population column as it is not changing
#   knitr::kable(digits = 1, align = "r")
```


<!-- To give attack rate by age group, with appropriate population denominators, use the following code.  -->



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// attack_rate_by_agegroup \\\
--------------------------------------------------------------------------------

This chunk calculates the attack rate by age group and then gives a table of
attack rate by group.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r attack_rate_by_agegroup, warning = FALSE}

# cases <- count(linelist_cleaned, age_group) %>%    # cases for each age_group
#   left_join(population_data_age, by = "age_group") # merge population data 
# 
# 
# # attack rate for each group
# attack_rate(cases$n, cases$population, multiplier = 10000, mergeCI = TRUE) %>% 
#   # add the epiweek column to table
#   bind_cols(select(cases, age_group), .) %>% 
#   rename("Age group" = age_group, 
#          "Cases (n)" = cases, 
#          "Population" = population, 
#          "AR (per 10,000)" = ar, 
#          "95%CI" = ci) %>% 
#   kable(digits = 1, format.args = list(big.mark = ",")) # set thousands separator
```



<!-- #### Mortality attributable to cholera -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This section can only be used if you are in a closed population (eg refugee
camp). The assumptions don't hold in an open/community setting.

This chunk calculates the attack rate by age group and then gives a table of
attack rate by group.

This section gives mortality rates attributable to cholera in a closed
population. It does not calculate all-cause mortality. It assumes that all
cholera deaths are among inpatients.

This demonstrates three ways of calculating mortality rate based on catchment
population (twice) and based on hospital population.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// collect_variables_rates \\\
--------------------------------------------------------------------------------

This chunk calculates key variables to do mortality rate.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r collect_variables_rates}

# count number of deaths 
# deaths <- sum(linelist_cleaned$DIED)
# 
# # outbreak duration in days 
# obs_time <- as.numeric(obs_end - obs_start)
# 
# # patient observation time 
# pat_obs_time <- linelist_cleaned %>% 
#   filter(!is.na(exit_status)) %>% 
#   summarise(days = sum(obs_days)) %>%
#   pull(days)
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// mortality_rate \\\
--------------------------------------------------------------------------------

To produce a mortality rate (attribuatble to cholera) per 10,000 people use
the following code chunk. This assumes that you are capturing every cholera
death in your population.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Mortality rate attributable to cholera per 10,000 population -->

```{r mortality_rate}

# mortality_rate(deaths, population, multiplier = 10000, mergeCI = TRUE) %>%
#   rename("Deaths" = deaths, 
#          "Population" = population, 
#          "Mortality (per 10,000)" = `mortality per 10 000`, 
#          "95%CI" = ci) %>% 
#   kable(digits = 1)
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// mortality_rate_CMR \\\
--------------------------------------------------------------------------------

To produce a crude mortality rate attributable to cholera per 10,000 people per 
day, use the folowing code chunk. 

This assumes that you are capturing every cholera death in your population and 
that your population remains stable over the time period of interest. 

In this situation the time period of interest is from the beginning of the 
epiweek your first case occured in, until the last day of the epiweek you are 
currently reporting on. (see this presentation (https://www.odi.org/sites/odi.org.uk/files/odi-assets/events-presentations/776.pdf) for more detail)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Crude mortality rate attributable to cholera per 10,000 population per day -->

```{r mortality_rate_CMR}

# mortality_rate(deaths, population*obs_time, multiplier = 10000, mergeCI = TRUE) %>%
#   rename("Deaths" = deaths, 
#          "Person-days" = population, 
#          "Mortality (per 10,000/day)" = `mortality per 10 000`, 
#          "95%CI" = ci) %>% 
#   kable(digits = 1)
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// mortality_rate_patients \\\
--------------------------------------------------------------------------------

Alternatively, if you are unsure whether your hospital deaths are
representative of the wider population, use the following code chunk. 
This uses the person days of cases in your linelist with a known outcome. 
However, this will give you an unreasonably high mortality rate, as 
those in hospital will only be the most severely affected. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Mortality rate attributable to cholera per 10,000 patients per day -->

```{r mortality_rate_patients}
# mortality_rate(deaths, pat_obs_time, multiplier = 10000, mergeCI = TRUE) %>%
#   rename("Deaths" = deaths, 
#          "Population" = population, 
#          "Mortality (per 10,000/day)" = `mortality per 10 000`, 
#          "95%CI" = ci) %>% 
#   kable(digits = 1)
```






<!-- ### Time -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This section focuses on the when of the outbreak:
- When did cases fall ill?
- Are numbers increasing or decreasing?

There is code to include an epi curve.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<!-- There were `r fmt_count(linelist_cleaned, is.na(date_of_onset))` cases missing dates of onset. -->

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// epicurve \\\
--------------------------------------------------------------------------------

# This chunk will calculate weekly incidence and plot your epicurve.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r epicurve, message = FALSE}

# count cases for each week of outbreak
# you can change the start of your week (eg "Sunday week", "Saturday week")
# inc_week_7 <- incidence(linelist_cleaned$date_of_onset, interval = "Monday week")
# 
# 
# # plot your epicurve
# basic_curve <- plot(inc_week_7, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7)) + 
#   scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
#   # add labels to axes and below chart
#   epicurve_labels +
#   # change visuals of dates and remove legend title
#   epicurve_theme
# 
# # show your plot (stored for later use) 
# basic_curve

## if the outbreak has been going on for a while, your x-axis might look messy.
## to reduce the number of labels, uncomment the below.
## you can customize the number of breaks by changing n_breaks
## you can also use months for your break (here in three-month intervals)

# basic_curve + scale_x_incidence(inc_week_7, n_breaks = 6)
# basic_curve + scale_x_date(breaks = "3 months", date_labels = "%b %Y")


```




<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// biweekly_epicurve \\\
--------------------------------------------------------------------------------

If needed, you can plot a biweekly epicurve. You can also do this by month,
quarter, or year. You can change the start of your week as needed.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r biweekly_epicurve, message = FALSE}

# create case counts for two week groups of your outbreak overall
# inc_week_14 <- incidence(linelist_cleaned$date_of_onset, interval = "2 Monday weeks")
# 
# 
# # plot your epicurve
# plot(inc_week_14, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_14)) + 
#   scale_y_continuous(expand = c(0,0)) +  # set origin for axes
#   # add labels to axes and below chart
#   epicurve_labels +
#   # change visuals of dates and remove legend title
#   epicurve_theme

```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// incidence_by_gender \\\
--------------------------------------------------------------------------------

You can plot weekly incidence by gender using this chunk.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r incidence_by_gender, message = FALSE}

# get counts by gender
# inc_week_7_gender <- incidence(linelist_cleaned$date_of_onset, 
#                                interval = "Monday week", 
#                                groups = linelist_cleaned$sex)
# 
# plot(inc_week_7_gender, 
#      show_cases = FALSE, # this removes black borders
#      border = "black", 
#      n_breaks = nrow(inc_week_7_gender)) + 
#   scale_y_continuous(expand = c(0,0)) +  # set origin for axes
#   epicurve_labels +
#   epicurve_theme

```

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// incidence_by_age_group \\\
--------------------------------------------------------------------------------

You can plot weekly incidence by age_group using this chunk.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

```{r incidence_by_age_group, message = FALSE}

# get counts by age
inc_week_7_age <- incidence(linelist_cleaned_current$date_of_onset, 
                               interval = "Monday week", 
                               groups = linelist_cleaned_current$age_group)

inc_week_7_age_plot <- plot(inc_week_7_age, 
                            show_cases = FALSE, # this removes black borders
                            border = "black", 
                            n_breaks = nrow(inc_week_7_age)) + 
  scale_y_continuous(expand = c(0,0)) +  # set origin for axes
  scale_x_date(breaks = "1 month", date_labels = "%d %b %Y") +
  epicurve_theme +
  labs(x = "Epi week", 
       y = "Cases (n)",
       title = "Cases by week of onset \nand age group",
       subtitle = str_glue("Source: MSF data from {reporting_week}")
  )

```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// incidence_by_case_def \\\
--------------------------------------------------------------------------------

This chunk shows the weekly incidence by case definition. You must have a
defined case definition variable.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r incidence_by_case_def, message = FALSE}
# inc_week_7_casedef <- incidence(linelist_cleaned$date_of_onset, 
#                                 interval = "Monday week", 
#                                 groups = linelist_cleaned$case_def)
# plot(inc_week_7_casedef, show_cases = TRUE, border = "black", n_breaks = nrow(inc_week_7_casedef)) + 
#   scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
#   # add labels to axes and below chart
#   epicurve_labels +
#   # change visuals of dates, remove legend title and move legend to bottom
#   epicurve_theme
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// incidence_by_outcome \\\
--------------------------------------------------------------------------------

This chunk shows the weekly incidence by outcome. 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r incidence_by_outcome, message = FALSE}

inc_week_7_outcome <- incidence(linelist_cleaned_current$date_of_onset,
                                interval = "Monday week",
                                groups = linelist_cleaned_current$exit_status)


inc_week_7_outcome_plot <- plot(inc_week_7_outcome, border = "black",
                                n_breaks = nrow(inc_week_7_outcome)) +
  scale_y_continuous(expand = c(0, 0)) +  # set origin for axes
  scale_x_date(breaks = "1 month", date_labels = "%d %b %Y") +
  # add labels to axes and below chart
  labs(x = "Calendar week", 
       y = "Cases (n)",
       title = "Cases by week of onset \nand outcome status",
       subtitle = str_glue("Source: MSF data from {reporting_week}")
  ) +
  # change visuals of dates, remove legend title and move legend to bottom
  epicurve_theme
```

### Epicurve

<!-- #### Combine epicurves -->
```{r combine_epicurves, fig.height = 5, fig.width = 7}

inc_week_7_age_plot  + inc_week_7_outcome_plot 

```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// attack_rate_per_week \\\
--------------------------------------------------------------------------------

This chunk creates a table of attack rate by week
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Attack rate per 10,000 population by week  -->

```{r attack_rate_per_week, warning = FALSE, message = FALSE}
# counts and cumulative counts by week
# cases <- linelist_cleaned %>%
#   arrange(date_of_onset) %>%        # arrange by date of onset
#   count(epiweek, .drop = FALSE) %>% # count all epiweeks and include zero counts
#   mutate(cumulative = cumsum(n))    # add a cumulative sum
# 
# 
# # attack rate for each week
# ar <- attack_rate(cases$n, population, multiplier = 10000) %>% 
#   bind_cols(select(cases, epiweek), .) # add the epiweek column to table
# 
# 
# ar %>%
#   merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
#   rename("Epiweek" = epiweek, 
#          "Cases (n)" = cases, 
#          "Population" = population, 
#          "AR (per 10,000)" = ar, 
#          "95%CI" = ci) %>% 
#   knitr::kable(digits = 1, align = "r")
```
 


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// cumulative_attack_rate_per_week \\\
--------------------------------------------------------------------------------

This chunk calculates the cumulative attack rate per week.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Cumulative attack rate per 10,000 population per week -->

```{r cumulative_attack_rate_per_week}

# attack_rate(cases$cumulative, population, multiplier = 10000) %>% 
#   bind_cols(select(cases, epiweek), .) %>% # add the epiweek column to table
#   merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
#   rename("Epiweek" = epiweek, 
#          "Cases (n)" = cases, 
#          "Population" = population, 
#          "AR (per 10,000)" = ar, 
#          "95%CI" = ci) %>% 
#   knitr::kable(digits = 1, align = "r")
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// cumulative_attack_rate_per_week \\\
--------------------------------------------------------------------------------

This chunk calculates the CFR among inpatients as a proportion per week.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Case fatality ratio as a proportion among inpatients by week -->

```{r cfr_per_week, warning = FALSE, message = FALSE}

# calculate CFR among inpatients by week
# cfr <- linelist_cleaned %>%
#   filter(patient_facility_type == "Inpatient") %>%
#   case_fatality_rate_df(str_detect(exit_status, "Dead"), group = epiweek)
# 
# 
# cfr %>%
#   merge_ci_df(e = 4) %>% # merge the lower and upper CI into one column
#   rename("Epiweek" = epiweek, 
#          "Deaths" = deaths, 
#          "Cases" = population, 
#          "CFR (%)" = cfr, 
#          "95%CI" = ci) %>% 
#   knitr::kable(digits = 1, align = "r")
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
You could plot the AR (in the population) and CFR (among inpatients only)
together with the epicurve by epiweek.

We will do this in three steps: 
- creating the AR graph (ar_line_graph)
- creating the CFR graph (cfr_line_graph)
- combining and plotting (epicurve_ar_cfr)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// ar_line_graph \\\
--------------------------------------------------------------------------------

This chunk sets up the AR graph. (It does not print the graph automatically.)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r ar_line_graph}

# ar_plot <- ggplot(ar, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
#   # add confidence intervals as a ribbon
#   geom_ribbon(aes(ymin = lower, ymax = upper), 
#               color = "blue",  fill = "blue", 
#               linetype = 2, alpha = 0.2, show.legend = FALSE) +
#   # add AR as a line
#   geom_line(aes(y = ar), color = "blue", show.legend = FALSE) +
#   # set origin for axes
#   scale_y_continuous(expand = c(0, 0)) +
#   # scale the x axis the same as the incidence curve. Expand forces it to align. 
#   incidence::scale_x_incidence(inc_week_7, 
#                                n_breaks = nrow(inc_week_7), 
#                                expand = c(0, 7 * 1.5)) +
#   # add labels to axes and below chart
#   labs(x = "Calendar week", y = "AR [95% CI]", subtitle = "Attack Rate (per 10,000)") + 
#   # change visuals of dates and remove legend title
#   epicurve_theme
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// cfr_line_graph \\\
--------------------------------------------------------------------------------

This chunk sets up the CFR graph. (It does not print the graph automatically.)
If you do not have any deaths in your data set, this will not show anything.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r cfr_line_graph}

# cfr_plot <- ggplot(cfr, aes(x = week2date(epiweek) + (7 * 0.5), group = 1)) +
#   # add confidence intervals as a ribbon
#   geom_ribbon(aes(ymin = lower, ymax = upper), 
#               color = "red", fill = "red", 
#               linetype = 2, alpha = 0.2, show.legend = FALSE) +
#   # add CFR as a line
#   geom_line(aes(y = cfr), color = "red", show.legend = FALSE) +
#   # set origin for axes
#   scale_y_continuous(expand = c(0, 0)) +  
#   # scale the x axis the same as the incidence curve. Expand forces it to align. 
#   incidence::scale_x_incidence(inc_week_7, 
#                                n_breaks = nrow(inc_week_7), 
#                                expand = c(0, 7 * 1.5)) +
#   # add labels to axes and below chart
#   labs(x = "Calendar week", y = "CFR [95% CI]", 
#        subtitle = "Case Fatality Ratio [95% CI] Among Inpatients") + 
#   # change visuals of dates and remove legend title
#   epicurve_theme 
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// epicurve_ar_cfr \\\
--------------------------------------------------------------------------------

This chunk prints the AR and CFR with the epicurve.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r epicurve_ar_cfr, warning = FALSE, message = FALSE, fig.height = 10}

# no_x <- theme(axis.text.x = element_blank(),
#               axis.title.x = element_blank())
# 
# ## use patchwork to stack the three plots on top of one another
# (basic_curve + no_x) / (ar_plot + no_x) / cfr_plot
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_admissions_by_epiweek \\\
--------------------------------------------------------------------------------

This chunk creates a table showing inpatient admissions by epiweek.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Inpatient admissions by case definition and week   -->

```{r describe_admissions_by_epiweek, warning = FALSE}

# linelist_cleaned %>% 
#   # filter(patient_facility_type == "Inpatient") %>%
#   tab_linelist(epiweek, strata = case_def,
#              col_total = TRUE,
#              row_total = TRUE) %>% 
#   select(-variable) %>%
#   rename_redundant("%" = proportion) %>%
#   augment_redundant(" (n)" = " n$") %>%
#   kable(digits = 1)
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_admissions_by_epiweek \\\
--------------------------------------------------------------------------------

This chunk creates a table showing inpatient exits by type per epiweek.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Inpatient discharges by reason for exit and week  -->

```{r describe_exits_by_epiweek, warning = FALSE}
# 
# linelist_cleaned %>% 
#   filter(patient_facility_type == "Inpatient") %>%
#   tab_linelist(epiweek, strata = exit_status2, 
#                col_total = TRUE, row_total = TRUE) %>% 
#   select(-variable) %>%
#   rename("Week" = value) %>%
#   rename_redundant("%" = proportion) %>%
#   augment_redundant(" (n)" = " n$") %>%
#   kable(digits = 1)
```






<!-- ### Place  -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This section focuses on the where of the outbreak: what area is affected, how
many villages, and so on.

There is code to include maps based on distribution of cases. You must have a
shapefile to create this map.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


<!-- #### Descriptive -->

### Case counts by camp

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_by_region_facility \\\
--------------------------------------------------------------------------------

This chunk creates a basic table of the number and percent of cases by region
and by facility. If you only have one facility, you can remove the strata.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Cases by camp and facility type -->

```{r describe_by_region_facility, warning = FALSE, message = FALSE, eval = FALSE}


# linelist_cleaned %>% 
#   select(patient_origin) %>% 
#   tbl_summary() 

```

<!-- ## Plot of cases by camp -->

```{r plot_cases_camp, echo = FALSE, fig.height = 5}

ggplot(linelist_cleaned_current, aes(x = patient_origin)) +
  geom_bar(fill  = "darkred") +
  theme_classic() +
  theme (text=element_text(size=10), axis.text.x= element_text(angle=90), legend.position= "none") +
  labs(x = "Camp",
       y = "Number of AWD cases",
       title = "Total number of AWD cases by camp since the start of the outbreak")


```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// describe_by_region_outcome \\\
--------------------------------------------------------------------------------

This chunk creates a basic table of the outcomes among inpatients by region.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Inpatient discharges by reason for exit and region  -->

```{r describe_by_region_outcome, warning = FALSE}
# 
# tab_linelist(filter(linelist_cleaned,
#                     patient_facility_type == "Inpatient"),
#              patient_origin, strata = exit_status2,
#              col_total = TRUE, row_total = TRUE) %>% 
#   select(-variable) %>%
#   rename("Region" = value) %>%
#   rename_redundant("%" = proportion) %>%
#   augment_redundant(" (n)" = " n$") %>%
#   kable(digits = 1)
```



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// attack_rate_by_region \\\
--------------------------------------------------------------------------------

If you do not have a shapefile, you may want to calculate attack rates by
region.

Consider facet wrapping by a larger unit if you have many regions (eg if you
have patients from 10+ villages, you may want to show your tables by health
zone)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<!-- Attack rage per 10,000 population by region  -->

```{r attack_rate_by_region, warning = FALSE}

# count cases by region
# cases <- count(linelist_cleaned, patient_origin) %>%
#   # add in population data
#   left_join(population_data_region, by = "patient_origin") 
# 
# 
# # calculate attack rate for region
# ar_region <- attack_rate(cases$n, cases$population, multiplier = 10000) %>% 
#   # add the region column to table
#   bind_cols(select(cases, patient_origin), .) %>% 
#   rename("Region" = patient_origin, 
#          "Cases (n)" = cases, 
#          "Population" = population, 
#          "AR (per 10,000)" = ar, 
#          "Lower 95%CI" = lower,
#          "Upper 95%CI" = upper) 
# 
# ar_region %>% 
#   merge_ci_df(e = 4) %>% # merge lower and upper CI in to one column 
#   rename("95%CI" = ci) %>%  # rename single 95%CI column
#   kable(digits = 1, align = "r", format.args = list(big.mark = ",")) # set thousands separator
```








<!-- ## Map -->
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// read_shapefiles \\\
--------------------------------------------------------------------------------

To create maps, you need to have a shapefile of the area. Often, the MSF GIS
unit can provide shapefiles.

Your shapefile can be a polygon or points. Polygons do not need to be contiguous.

The names of the polygons or points MUST match the names in your linelist.

Your coordinate reference system needs to be WGS84.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
```{r read_shapefiles, echo = FALSE, message=FALSE, warning = FALSE, message = FALSE}

## read in shapefile
map <- read_sf(here::here("../../../2_GIS/GIS/MSF_GIS_Folder/Camp shape file/Site_boundaries.shp")) %>% 
  ## change all variables to lower case
  janitor::clean_names()

## create a subset of map file with only the main camp area
map <- map %>% 
  filter(!site_name %in% c("Camp 21", "Camp 22", 
                           "Camp 23", "Camp 24",
                           "Camp 25", "Camp 26", 
                           "Camp 27", "Choukali",
                           "Nayapara RC"))
```


<!-- ## Base layer from OSM -->

```{r obtain_base_layer, echo = FALSE, warning = FALSE, message = FALSE}

tiles <- cartography::getTiles(
  map,
  type = "OpenStreetMap",
  zoom = NULL,
  crop = TRUE,
  verbose = FALSE,
  apikey = NA,
  cachedir = FALSE,
  forceDownload = FALSE
)

```


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// choropleth_maps \\\
--------------------------------------------------------------------------------

Once you have loaded your shapefile, you can map the case counts or attack rates.

Make sure you delete or comment out the section you are not using.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<!-- ## All AWD cases -->

```{r choropleth_awd_all_time_maps, message = FALSE, warning = FALSE}

## Create a summary database that counts the number of cases per camp
total_awd_counts <- linelist_cleaned_current %>% 
  ## select site_name and count
  select(site_name) %>% 
  group_by_all() %>% 
  tally()

## Join total AWD by camp count dataset with map file
awd_all_time <- map %>% 
  ## join the count data from past month verified dataset
  left_join(total_awd_counts,
            by = "site_name") %>% 
  
    ## create levels for counts of covid
  mutate(awd_counts =  fac_from_num(n))%>% 
  ## remove the NA from awd_counts
  filter(is.na(awd_counts) == FALSE)
  


## Plot map of cases by block
awd_all_time_map <- ggplot() +
  ## add in the back ground tiles
  ggspatial::layer_spatial(tiles, interpolate = TRUE) +
  # shapefile as polygon
  geom_sf(data = awd_all_time, aes(fill = awd_counts)) + 
  # needed to avoid gridlines being drawn
  coord_sf(datum = NA) + 
  # add a scalebar
  annotation_scale() + 
  # choose palette colour for fill
  scale_fill_brewer(palette = "YlOrRd") +
  ## Add camp number as label
  geom_sf_text(data = awd_all_time, aes(label = site_name), colour = "black",
               size = 2.5) +
  theme_void() +
  theme(plot.title = element_text(size= 12)) +
  labs(fill = "No. of cases",
       captions = str_glue("Source: MSF data from {reporting_week}"),
       title = str_glue("Number of suspected AWD\n cases in Cox's Bazar up to {reporting_week}"))
  



```


<!-- ##  AWD cases in past week -->

```{r choropleth_awd_past_week_maps, message = FALSE, warning = FALSE}

## Create a summary database that counts the number of cases per camp
past_week_awd_counts <- linelist_cleaned_current %>% 
  ## filter only on reportingn week
  filter(epiweek == reporting_week) %>% 
  ## select site_name and count
  select(site_name) %>% 
  group_by_all() %>% 
  tally()

## Join total AWD by camp count dataset with map file
awd_past_week <- map %>% 
  ## join the count data from past month verified dataset
  left_join(past_week_awd_counts,
            by = "site_name") %>% 
  
    ## create levels for counts of covid
  mutate(awd_counts =  fac_from_num(n))%>% 
  ## remove the NA from awd_counts
  filter(is.na(awd_counts) == FALSE)
  


## Plot map of cases by block
awd_past_week_map <- ggplot() +
  ## add in the back ground tiles
  ggspatial::layer_spatial(tiles, interpolate = TRUE) +
  # shapefile as polygon
  geom_sf(data = awd_past_week, aes(fill = awd_counts)) + 
  # needed to avoid gridlines being drawn
  coord_sf(datum = NA) + 
  # add a scalebar
  annotation_scale() + 
  # choose palette colour for fill
  scale_fill_brewer(palette = "YlOrRd") +
  ## Add camp number as label
  geom_sf_text(data = awd_past_week, aes(label = site_name), colour = "black",
               size = 2.5) +
  theme_void() +
  theme(plot.title = element_text(size= 12)) +
  labs(fill = "No. of cases",
       captions = str_glue("Source: MSF data from {reporting_week}"),
       title = str_glue("Number of suspected AWD\n cases in Cox's Bazar in {reporting_week}"))
  



```


<!-- #### Combine AWD maps -->
```{r combine_awd_maps, fig.height = 5, fig.width= 7, warning  = FALSE, error = FALSE, message = FALSE}

awd_all_time_map  + awd_past_week_map 

```

